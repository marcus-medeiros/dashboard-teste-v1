# Arquivo: dashboard_realtime.py
# Descri√ß√£o: Recebe dados via MQTT e os exibe em um gr√°fico de tempo real no Streamlit.

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import paho.mqtt.client as mqtt
import threading
from datetime import datetime, timedelta

# --- Configura√ß√µes ---
MQTT_BROKER = "broker.hivemq.com"
MQTT_PORT = 1883
MQTT_TOPIC = "bess/energia"
DATA_WINDOW_SECONDS = 60 # Janela de tempo dos dados a serem exibidos (60 segundos)

# --- Gerenciamento de Estado do Streamlit ---
# Usamos o st.session_state para manter os dados entre as atualiza√ß√µes da p√°gina
if 'timestamps' not in st.session_state:
    st.session_state.timestamps = []
if 'values' not in st.session_state:
    st.session_state.values = []
if 'mqtt_started' not in st.session_state:
    st.session_state.mqtt_started = False

# --- L√≥gica MQTT (executar√° em uma thread separada) ---

def on_connect(client, userdata, flags, rc):
    """Callback de conex√£o."""
    if rc == 0:
        print("Conex√£o com MQTT estabelecida com sucesso.")
        client.subscribe(MQTT_TOPIC)
    else:
        print(f"Falha na conex√£o com MQTT, c√≥digo: {rc}")

def on_message(client, userdata, msg):
    """Callback de recebimento de mensagens."""
    try:
        valor = float(msg.payload.decode('utf-8'))
        agora = datetime.now()

        st.session_state.timestamps.append(agora)
        st.session_state.values.append(valor)

        # L√≥gica para manter apenas os dados da janela de tempo definida (sliding window)
        limite_tempo = agora - timedelta(seconds=DATA_WINDOW_SECONDS)
        while st.session_state.timestamps and st.session_state.timestamps[0] < limite_tempo:
            st.session_state.timestamps.pop(0)
            st.session_state.values.pop(0)

    except ValueError:
        # Ignora mensagens que n√£o podem ser convertidas para float
        pass

def start_mqtt_client():
    """Inicia o cliente MQTT em uma thread separada para n√£o bloquear o Streamlit."""
    client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION1)
    client.on_connect = on_connect
    client.on_message = on_message
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    client.loop_forever()

# --- Inicia a thread do MQTT apenas uma vez por sess√£o ---
if not st.session_state.mqtt_started:
    print("Iniciando a thread do cliente MQTT...")
    mqtt_thread = threading.Thread(target=start_mqtt_client, daemon=True)
    mqtt_thread.start()
    st.session_state.mqtt_started = True

# --- Interface Gr√°fica do Streamlit ---
st.set_page_config(page_title="Dashboard BESS em Tempo Real", layout="wide")
st.title("üîã Dashboard BESS em Tempo Real")
st.markdown(f"Exibindo dados do t√≥pico `{MQTT_TOPIC}` nos √∫ltimos {DATA_WINDOW_SECONDS} segundos.")

# Placeholder para o gr√°fico, para que possamos atualiz√°-lo
placeholder = st.empty()

# Cria c√≥pias dos dados para evitar problemas de concorr√™ncia com a thread
current_timestamps = list(st.session_state.timestamps)
current_values = list(st.session_state.values)

with placeholder.container():
    # --- M√©tricas ---
    col1, col2 = st.columns(2)
    if current_values:
        last_value = current_values[-1]
        avg_value = sum(current_values) / len(current_values)
        col1.metric("Pot√™ncia Atual", f"{last_value:.2f} kW")
        col2.metric("Pot√™ncia M√©dia (na janela)", f"{avg_value:.2f} kW")
    else:
        col1.metric("Pot√™ncia Atual", "Aguardando...")
        col2.metric("Pot√™ncia M√©dia", "Aguardando...")

    # --- Gr√°fico ---
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=current_timestamps,
        y=current_values,
        mode='lines+markers',
        name='Pot√™ncia',
        line=dict(color='deepskyblue', width=3)
    ))
    fig.update_layout(
        height=500,
        xaxis_title='Hor√°rio',
        yaxis_title='Pot√™ncia (kW)',
        # Define o range do eixo X para ser exatamente a janela de tempo
        xaxis=dict(range=[datetime.now() - timedelta(seconds=DATA_WINDOW_SECONDS), datetime.now()])
    )
    st.plotly_chart(fig, use_container_width=True)

# For√ßa a re-execu√ß√£o do script a cada 1 segundo para atualizar a UI
st.rerun(ttl=1)